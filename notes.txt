struct addrinfo {
    int ai_flags;                   // AI_PASSIVE, AI_CANONNAME, etc. (?)
    int ai_family;                  // AF_INET, AF_INET6, AF_UNSPEC
    int ai_socktype;                // SOCK_STREAM, SOCK_DGRAM
    int ai_protocol;                // use 0 for "any"
    size_t ai_addrlen;              // size of ai_addr in bytes; 
    struct sockaddr *ai_addr;       // struct sockaddr_in or _in6
    char *ai_canoname;              // full canonical hostname
    struct addrinfo *ai_next;       // linked list, next addrinfo node
};

You typically load this struct with some information and then call getaddrinfo().
Which returns a linked list of addrinfo's.

struct sockaddr {
    unsigned short sa_family;       // address family, AF_XXX
    char sa_data[14];               // 14 bytes of protocol address
};
sa_data contains the destination address and port number for the socket. Since it's 
quite tedious and error-prone to write this by hand we usually use another structure
(struct sockaddr_in for IPv4 or struct sockaddr_in6 for IPv6) and cast it into a char[].

struct sockaddr_in {
    short int sin_family;           // Address family, AF_INET
    unsigned short int sin_port;    // Port number
    struct in_addr sin_addr;        // Internet address
    unsigned char sin_zero[8];      // Same size as struct sockaddr
};

struct in_addr {
    uint32_t s_addr; // that's a 32-bit in (4 bytes)
};

struct sockaddr_in6 {
    u_int16_t sin6_family;          // Address family, AF_INET6
    u_int16_t sin6_port;            // port number, Network Byte Order
    u_int32_t sin6_flowinfo;        // IPv6 flow information
    struct in6_addr sin6_addr;      // IPv6 address
    u_int32_t sin6_scope_id;        // Scope ID
};

struct in6_addr {
    unsigned char s6_addr[16];      // IPv6 address
}

inet_pton() converts an IP address in numbers-and-dots notation into either a struct
in_addr or a struct in6_addr depending on whether you specify AF_INET or AF_INET6.

// A declaration
struct sockaddr_in sa; // IPv4
struct sockaddr_in6 sa6; // IPv6

// Note: ideally you'd like to supplement this with some error checking
inet_pton(AF_INET, "10.12.110.57", &(sa.sin_addr)); // IPv4
inet_pton(AF_INET6, "2001:db8:63b3:1::3490", &(sa6.sin6_addr)); // IPv6

// IPv4;
char ip4[INET_ADDRSTRLEN];  // Space to hold the IPv4 string
struct sockaddr_in sa;      // pretend this is loaded with something

inet_ntop(AF_INET, &(sa.sin_addr), ip4, INET_ADDRSTRLEN);

printf("The IPv4 address is %s\n", ip4); 

// IPv6: 
char ip6[INET6_ADDRSTRLEN]; // space to hold the IPv6 string
struct sockaddr_in6 sa6;    // pretend this is loaded with something

inet_ntop(AF_INET6, &(sa6.sin6_addr), ip6, INET6_ADDRSTRLEN); 

printf("The address is: %s\n", ip6); 

The process of translating an "internal" IP address to an "external" IP address 
is called Network Address Translation.

getaddrinfo()

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

int getaddrinfo(const char *node,       // e.g. "www.example.com" or IP
                const char *service,    // e.g. "http" or port number
                const struct addrinfo *hints, 
                struct addrinfo **res); 

The node parameter is the host name to connect to, or an IP address
Next the parameter service, which can be a port number, like "80", or 
the name of a particular servce like "http", or "ftp" or anything else.
The hints parameter points to a struct addrinfo that you've already filled
out with relevant information.

Eg. Setup for a server who wants to listen on the host's IP address on port 3490 -
int status; 
struct addrinfo hints;
struct addrinfo *servinfo; // will point to the results

memset(&hints, 0, sizeof hints);    // make sure the struct is empty
hints.ai_family = AF_UNSPEC;        // don't care IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM;    // TCP stream sockets
hints.ai_flags = AI_PASSIVE;        // fill in my IP for me 

if ((status = getaddrinfo(NULL, "3490", &hints, &servinfo)) != 0) {
    fprintf(stderr, "getaddrinfo error: %s\n", gai_strerror(status));
    exit(1); 
}

// servinfo now points to a linked list of 1 or more struct addrinfos

// ... do everything until you don't need servinfo anymore ... 

freeaddrinfo(servinfo);     // free the linked-list

Eg. Setup for a client who wants to connect to a particular server on port 3490 - 
int status; 
struct addrinfo hints; 
struct addrinfo *servinfo;  // will point to the results

memset(&hints, 0, sizeof hints);    // make sure the struct is empty
hints.ai_family = AF_UNSPEC;        // don't care IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM;    // TCP stream sockets

// get ready to connect 
status = getaddrinfo("www.example.net", "3490", &hints, &servinfo); 

// servinfo now points to a linked list of 1 or more struct addrinfos

// etc. 




Open Questions
--------------

1. Why does getaddrinfo() return a linked list of addrinfo's as opposed to just a single
   filled out addrinfo? - cause there can be many IP addresses assoicated to a single request


